# Load character animations
self.animations = {
    'idle': [],
    'running': [],
    'jumping': []
}

# Load idle animation
try:
    idle_dir = os.path.join(ASSETS_DIR, "animations", "idle")
    if os.path.exists(idle_dir):
        idle_frame = pygame.image.load(os.path.join(idle_dir, "idleFrame1.png")).convert_alpha()
        self.animations['idle'].append(idle_frame)
except Exception as e:
    print(f"Error loading idle animation: {e}")

# Load running animation
try:
    running_dir = os.path.join(ASSETS_DIR, "animations", "running")
    if os.path.exists(running_dir):
        for i in range(1, 9):  # There are 8 running frames
            try:
                frame = pygame.image.load(os.path.join(running_dir, f"runningFrame{i}.png")).convert_alpha()
                self.animations['running'].append(frame)
            except:
                break
except Exception as e:
    print(f"Error loading running animation: {e}")

# Load jumping animation
try:
    jumping_dir = os.path.join(ASSETS_DIR, "animations", "jumping")
    if os.path.exists(jumping_dir):
        jumping_frame = pygame.image.load(os.path.join(jumping_dir, "jumpingFrame1.png")).convert_alpha()
        self.animations['jumping'].append(jumping_frame)
except Exception as e:
    print(f"Error loading jumping animation: {e}")

# Animation state
self.current_animation = 'running'
self.animation_frame = 0
self.animation_speed = 0.1  # Speed of animation (frames per update)
self.animation_timer = 0
self.character_x = 100  # Character position
self.character_y = HEIGHT - 150
self.character_scale = 2.0  # Scale factor for the characterdef update_animation(self):
    # Update animation frame
    self.animation_timer += self.animation_speed
    if self.animation_timer >= 1:
        self.animation_timer = 0
        if self.current_animation == 'running' and self.animations['running']:
            self.animation_frame = (self.animation_frame + 1) % len(self.animations['running'])
        elif self.current_animation == 'jumping':
            # For jumping, we just use one frame
            self.animation_frame = 0
        else:  # idle
            self.animation_frame = 0# Inside the check_answer method, when setting self.result = True:
            self.current_animation = 'jumping'  # Jump when correct
            
            # When setting self.result = False:
            self.current_animation = 'idle'  # Idle when wrong# Update animation
            self.update_animation()
            
            # Draw character animation
            if self.current_animation in self.animations and self.animations[self.current_animation]:
                # Get the current frame
                if self.current_animation == 'running':
                    frame = self.animations['running'][self.animation_frame] if self.animations['running'] else None
                elif self.current_animation == 'jumping':
                    frame = self.animations['jumping'][0] if self.animations['jumping'] else None
                else:  # idle
                    frame = self.animations['idle'][0] if self.animations['idle'] else None
                
                if frame:
                    # Scale the frame
                    scaled_frame = pygame.transform.scale(
                        frame, 
                        (int(frame.get_width() * self.character_scale), 
                         int(frame.get_height() * self.character_scale))
                    )
                    
                    # Draw the character
                    screen.blit(scaled_frame, (self.character_x, self.character_y))# Reset animation to running
                    self.current_animation = 'running'
import pygame
import random
import os
from PIL import Image
import io
import math
import sys

# Initialize Pygame
pygame.init()

# Constants
SCREEN_WIDTH = 1200
SCREEN_HEIGHT = 800
TILE_SIZE = 48
PLAYER_WIDTH = 64
PLAYER_HEIGHT = 64
GRAVITY = 0.8
JUMP_SPEED = -15
MOVE_SPEED = 5

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)

print("Current working directory:", os.getcwd())

class QuizSystem:
    def __init__(self):
        # Quiz questions from the file
        self.questions = {
            "Mercury": [
                {
                    "question": "What is Mercury's position from the Sun?",
                    "options": ["1st", "2nd", "3rd", "4th"],
                    "correct": 0
                },
                {
                    "question": "What is Mercury's atmosphere mostly made of?",
                    "options": ["It has almost no atmosphere", "Oxygen", "Hydrogen", "Carbon dioxide"],
                    "correct": 0
                },
                {
                    "question": "How long is a year on Mercury?",
                    "options": ["88 Earth days", "225 Earth days", "365 Earth days", "687 Earth days"],
                    "correct": 0
                },
                {
                    "question": "What is the largest feature on Mercury's surface?",
                    "options": ["Caloris Basin", "Olympus Mons", "Valles Marineris", "Tycho Crater"],
                    "correct": 0
                },
                {
                    "question": "What percentage of Mercury's volume is its core?",
                    "options": ["55%", "25%", "35%", "45%"],
                    "correct": 0
                },
                {
                    "question": "What has been discovered in Mercury's polar craters?",
                    "options": ["Water ice", "Methane ice", "Ammonia ice", "Carbon dioxide ice"],
                    "correct": 0
                },
                {
                    "question": "What is Mercury's surface gravity compared to Earth's?",
                    "options": ["38%", "50%", "25%", "75%"],
                    "correct": 0
                },
                {
                    "question": "Which spacecraft first visited Mercury?",
                    "options": ["Mariner 10", "Voyager 1", "Pioneer", "New Horizons"],
                    "correct": 0
                },
                {
                    "question": "What causes Mercury's extreme temperature variations?",
                    "options": ["Lack of atmosphere", "Distance from Sun", "Slow rotation", "Solar winds"],
                    "correct": 0
                },
                {
                    "question": "What type of exosphere does Mercury have?",
                    "options": ["Very thin", "Thick", "Moderate", "None"],
                    "correct": 0
                }
            ],
            "Venus": [
                {
                    "question": "What is Venus mostly covered by?",
                    "options": ["Thick clouds of sulfuric acid", "Water", "Ice", "Sand dunes"],
                    "correct": 0
                },
                {
                    "question": "Venus is often called the...",
                    "options": ["Earth's Twin", "Red Planet", "Blue Giant", "Ice Planet"],
                    "correct": 0
                },
                {
                    "question": "Which planet has the hottest surface temperature?",
                    "options": ["Venus", "Mercury", "Mars", "Jupiter"],
                    "correct": 0
                }
            ],
            "Earth": [
                "Earth is the only known planet with liquid water on its surface.",
                "Our planet's atmosphere is primarily nitrogen and oxygen.",
                "Earth is the only planet known to support life.",
                "The planet's magnetic field protects us from harmful solar radiation.",
                "Earth's atmosphere contains the perfect balance of gases for life.",
                "Our planet is the densest of all planets in the solar system.",
                "Earth's core creates a magnetic field that enables navigation.",
                "The planet is approximately 4.54 billion years old.",
                "Earth is the only planet not named after a god or goddess.",
                "71% of Earth's surface is covered by water.",
                "The highest point is Mount Everest at 8,848 meters.",
                "Earth's ozone layer protects life from harmful UV radiation.",
                "Our planet has one natural satellite: the Moon."
            ],
            "Mars": [
                "Mars has the largest volcano in the solar system: Olympus Mons.",
                "Mars has two small moons: Phobos and Deimos.",
                "The red color comes from iron oxide (rust) on its surface.",
                "Mars has the largest canyon in the solar system: Valles Marineris.",
                "Scientists have found evidence of ancient water flows on Mars.",
                "The planet experiences frequent dust storms.",
                "Mars' atmosphere is primarily carbon dioxide.",
                "The planet has polar ice caps made of water and CO2 ice.",
                "A year on Mars is about 687 Earth days.",
                "Mars has about 38% of Earth's gravity.",
                "The planet experiences seasons like Earth.",
                "Temperatures can range from 20°C to -140°C.",
                "Multiple rovers have successfully explored the Martian surface."
            ],
            "Jupiter": [
                "Jupiter is the largest planet in our solar system.",
                "The Great Red Spot is a giant storm that has lasted for centuries.",
                "Jupiter has at least 79 moons."
            ],
            "Saturn": [
                "Saturn's beautiful rings are made mostly of ice and rock.",
                "Saturn has over 80 moons, with Titan being the largest.",
                "Saturn is the least dense planet in the solar system."
            ],
            "Uranus": [
                "Uranus rotates on its side, unlike other planets.",
                "It appears blue-green due to methane in its atmosphere.",
                "Uranus has 27 known moons."
            ],
            "Neptune": [
                "Neptune has the strongest winds in the solar system.",
                "It has a dark spot similar to Jupiter's Great Red Spot.",
                "Neptune's largest moon, Triton, orbits backwards."
            ]
        }
        self.current_questions = {}
        
    def get_random_question(self, planet_name):
        if planet_name in self.questions:
            return random.choice(self.questions[planet_name])
        return None

class Background:
    def __init__(self, image_path=None, is_earth=False, planet_name=""):
        self.is_earth = is_earth
        self.planet_name = planet_name
        if is_earth:
            try:
                self.image = pygame.image.load(image_path).convert_alpha()
                self.width = self.image.get_width()
                self.height = self.image.get_height()
                scale_factor = SCREEN_HEIGHT / self.height
                new_width = int(self.width * scale_factor)
                self.image = pygame.transform.scale(self.image, (new_width, SCREEN_HEIGHT))
                self.width = new_width
                global WORLD_WIDTH
                WORLD_WIDTH = self.width
            except pygame.error as e:
                print(f"Could not load background image: {e}")
                self.fallback_background()
        else:
            self.fallback_background()
            
    def create_planet_specific_stars(self):
        stars = []
        if self.planet_name == "Mercury":
            # Hot, bright environment with intense sun
            for _ in range(150):
                x = random.randint(0, self.width)
                y = random.randint(0, SCREEN_HEIGHT)
                radius = random.randint(1, 4)
                color = (random.randint(200, 255), random.randint(200, 255), random.randint(150, 200))
                stars.append((x, y, radius, color))
                
        elif self.planet_name == "Venus":
            # Thick, toxic atmosphere with yellowish tint
            for _ in range(100):
                x = random.randint(0, self.width)
                y = random.randint(0, SCREEN_HEIGHT)
                radius = random.randint(1, 3)
                color = (random.randint(200, 255), random.randint(150, 200), random.randint(0, 50))
                stars.append((x, y, radius, color))
                
        elif self.planet_name == "Mars":
            # Red dust storms and thin atmosphere
            for _ in range(120):
                x = random.randint(0, self.width)
                y = random.randint(0, SCREEN_HEIGHT)
                radius = random.randint(1, 3)
                color = (random.randint(200, 255), random.randint(50, 100), random.randint(0, 50))
                stars.append((x, y, radius, color))
                
        elif self.planet_name == "Jupiter":
            # Gas giant with swirling clouds
            for _ in range(200):
                x = random.randint(0, self.width)
                y = random.randint(0, SCREEN_HEIGHT)
                radius = random.randint(2, 5)
                color = (random.randint(150, 200), random.randint(100, 150), random.randint(50, 100))
                stars.append((x, y, radius, color))
                
        elif self.planet_name == "Saturn":
            # Ringed planet with golden hue
            for _ in range(180):
                x = random.randint(0, self.width)
                y = random.randint(0, SCREEN_HEIGHT)
                radius = random.randint(1, 4)
                color = (random.randint(200, 255), random.randint(180, 220), random.randint(100, 150))
                stars.append((x, y, radius, color))
                
        elif self.planet_name == "Uranus":
            # Ice giant with blue-green atmosphere
            for _ in range(150):
                x = random.randint(0, self.width)
                y = random.randint(0, SCREEN_HEIGHT)
                radius = random.randint(1, 3)
                color = (random.randint(100, 150), random.randint(150, 200), random.randint(200, 255))
                stars.append((x, y, radius, color))
                
        elif self.planet_name == "Neptune":
            # Dark blue planet with strong winds
            for _ in range(170):
                x = random.randint(0, self.width)
                y = random.randint(0, SCREEN_HEIGHT)
                radius = random.randint(1, 4)
                color = (random.randint(0, 50), random.randint(100, 150), random.randint(200, 255))
                stars.append((x, y, radius, color))
        
        return stars
    
    def fallback_background(self):
        self.width = SCREEN_WIDTH * 3
        global WORLD_WIDTH
        WORLD_WIDTH = self.width
        self.stars = self.create_planet_specific_stars()
    
    def draw(self, screen, camera_x):
        if self.is_earth:
            parallax_x = camera_x * 0.5
            rel_x = parallax_x % self.width
            screen.blit(self.image, (rel_x - self.width, 0))
            screen.blit(self.image, (rel_x, 0))
        else:
            # Create planet-specific background color
            if self.planet_name == "Mercury":
                screen.fill((60, 50, 40))  # Hot, rocky surface
            elif self.planet_name == "Venus":
                screen.fill((70, 50, 20))  # Yellowish toxic atmosphere
            elif self.planet_name == "Mars":
                screen.fill((80, 30, 20))  # Red planet
            elif self.planet_name == "Jupiter":
                screen.fill((70, 60, 40))  # Gas giant
            elif self.planet_name == "Saturn":
                screen.fill((80, 70, 50))  # Golden hue
            elif self.planet_name == "Uranus":
                screen.fill((40, 60, 70))  # Blue-green ice giant
            elif self.planet_name == "Neptune":
                screen.fill((20, 40, 80))  # Deep blue
            else:
                screen.fill(BLACK)
            # Draw stars with parallax and effects
            for star in self.stars:
                x, y, radius, color = star
                parallax_x = (-camera_x * 0.2)
                star_x = (x + parallax_x) % self.width
                
                # Add twinkling effect
                brightness = abs(math.sin(pygame.time.get_ticks() * 0.001 + x * 0.1))
                twinkle_color = tuple(int(c * brightness) for c in color)
                
                # Draw the star with a glow effect
                pygame.draw.circle(screen, twinkle_color, (int(star_x), y), radius + 1, 1)
                pygame.draw.circle(screen, twinkle_color, (int(star_x), y), radius)

class Camera:
    def __init__(self, width, height):
        self.camera = pygame.Rect(0, 0, width, height)
        self.width = width
        self.height = height
        self.scroll_speed = MOVE_SPEED
        self.x = 0  # Store actual x position for parallax

    def apply(self, entity):
        return entity.rect.move(self.camera.topleft)

    def update(self, target):
        self.x = -target.rect.centerx + SCREEN_WIDTH // 2
        
        # Limit scrolling to world boundaries
        self.x = min(0, self.x)  # Left boundary
        self.x = max(-(WORLD_WIDTH - SCREEN_WIDTH), self.x)  # Right boundary
        
        self.camera = pygame.Rect(self.x, 0, self.width, self.height)

class InfoButton(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        # Make buttons bigger by increasing width and height
        self.width = TILE_SIZE * 3  # Increased width to 3 tiles
        self.height = TILE_SIZE * 1.5  # Increased height to 1.5 tiles
        
        # Load button images
        try:
            self.button_normal = pygame.image.load(os.path.join('assets', 'FactsButton', 'buttonNotPressed.png')).convert_alpha()
            self.button_pressed = pygame.image.load(os.path.join('assets', 'FactsButton', 'buttonPressed.png')).convert_alpha()
            
            # Scale images to match the new bigger size
            self.button_normal = pygame.transform.scale(self.button_normal, (self.width, self.height))
            self.button_pressed = pygame.transform.scale(self.button_pressed, (self.width, self.height))
        except pygame.error as e:
            print(f"Error loading button images: {e}")
            # Fallback to simple colored rectangles if images fail to load
            self.button_normal = pygame.Surface((self.width, self.height))
            self.button_pressed = pygame.Surface((self.width, self.height))
            self.button_normal.fill((200, 0, 0))
            self.button_pressed.fill((150, 0, 0))
        
        self.image = self.button_normal
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.bottom = y
        
        # Button state variables
        self.is_pressed = False
        self.cooldown = 0
        self.player_on_button = False
        self.button_pressed = False
        
        # Update glow effect for larger size
        self.glow_images = []
        for i in range(5):
            glow_surf = pygame.Surface((self.width + i*4, self.height + i*4), pygame.SRCALPHA)
            alpha = 100 - i * 20
            pygame.draw.rect(glow_surf, (255, 50, 50, alpha), 
                           glow_surf.get_rect(), border_radius=5)
            self.glow_images.append(glow_surf)
        self.glow_index = 0
        self.glow_timer = 0

    def update(self):
        if self.cooldown > 0:
            self.cooldown -= 1
        
        # Reset button_pressed when player is not on button
        if not self.player_on_button:
            self.button_pressed = False
            self.image = self.button_normal
        else:
            self.image = self.button_pressed
        
        # Animate glow
        self.glow_timer += 1
        if self.glow_timer > 5:
            self.glow_timer = 0
            self.glow_index = (self.glow_index + 1) % len(self.glow_images)

class InfoBubble(pygame.sprite.Sprite):
    def __init__(self, x, y, fact_index, parent_button, planet_facts, quiz_system=None, planet_name=None):
        super().__init__()
        self.font = pygame.font.Font(None, 32)
        self.quiz_system = quiz_system
        self.planet_name = planet_name
        self.current_question = None
        self.show_quiz = False
        self.show_result = False
        self.result_text = ""
        
        # Store the fact text without exit message
        self.fact_text = planet_facts[fact_index] if fact_index < len(planet_facts) else "No fact available"
        self.full_text = self.fact_text
        
        # Create separate surface for exit text
        self.exit_text = "Press Escape to exit"
        self.exit_surface = self.font.render(self.exit_text, True, (255, 255, 255))
        self.exit_rect = self.exit_surface.get_rect()
        
        # Position the exit text at bottom right
        screen = pygame.display.get_surface()
        self.exit_rect.bottomright = (screen.get_width() - 20, screen.get_height() - 20)
        
        self.selected_option = None
        self.correct_answer = None
        
        self.current_text = ""
        self.text_index = 0
        self.typing_speed = 2
        self.typing_timer = 0
        self.typing_delay = 1
        self.done_typing = False
        self.padding = 20
        self.border_radius = 15
        self.parent_button = parent_button
        
        # Calculate maximum width for text wrapping
        self.max_width = SCREEN_WIDTH // 2
        self.wrapped_text = self.wrap_text(self.full_text)
        
        # Create initial surface
        self.create_surface()
        
        self.rect = self.image.get_rect()
        self.rect.centerx = x
        self.rect.y = y
        
        # Fade in/out properties
        self.alpha = 0
        self.fade_speed = 5
        self.fade_in = True
        self.display_time = 90
        self.display_timer = 0
        self.active = True
        self.start_fade = False
        self.parent_game = None  # Reference to PlanetPlatformer instance

    def wrap_text(self, text):
        words = text.split()
        lines = []
        current_line = []
        current_width = 0
        
        for word in words:
            word_surface = self.font.render(word + " ", True, BLACK)
            word_width = word_surface.get_width()
            
            if current_width + word_width <= self.max_width:
                current_line.append(word)
                current_width += word_width
            else:
                lines.append(" ".join(current_line))
                current_line = [word]
                current_width = word_width
        
        if current_line:
            lines.append(" ".join(current_line))
        
        return lines

    def create_surface(self):
        # Calculate required height for all lines
        line_height = self.font.get_linesize()
        total_height = (len(self.wrapped_text) * line_height) + (self.padding * 2)
        
        # Create surface
        self.image = pygame.Surface((self.max_width + self.padding * 2, total_height), pygame.SRCALPHA)
        
        # Draw background with gradient
        for i in range(3):
            alpha = 180 - (i * 30)
            pygame.draw.rect(self.image, (255, 255, 255, alpha),
                           self.image.get_rect(),
                           border_radius=self.border_radius-i)
        
        # Render current text
        y_offset = self.padding
        for i, line in enumerate(self.wrapped_text):
            if i * line_height > self.text_index * 2:
                break
            render_text = line[:max(0, self.text_index - i * len(line))]
            if render_text:
                text_surface = self.font.render(render_text, True, BLACK)
                self.image.blit(text_surface, (self.padding, y_offset))
            y_offset += line_height

    def handle_key_press(self, key):
        if not self.current_question or self.show_result:
            return
        
        # Convert key press to option index (A=0, B=1, etc.)
        option_keys = {
            pygame.K_a: 0, pygame.K_b: 1,
            pygame.K_c: 2, pygame.K_d: 3
        }
        
        if key in option_keys:
            self.selected_option = option_keys[key]
            self.show_result = True
            self.result_timer = 60  # Show result for 60 frames
            
            # Check if answer is correct
            if self.selected_option == self.current_question["correct"]:
                # Get new question
                self.current_question = self.quiz_system.get_random_question(self.planet_name)
                self.show_result = False
                self.selected_option = None
                
                # Update text with new question
                if self.current_question:
                    self.full_text = self.current_question["question"] + "\n\n"
                    for i, option in enumerate(self.current_question["options"]):
                        self.full_text += f"{chr(65+i)}) {option}\n"
                    self.text_index = 0
                    self.done_typing = False
                    self.create_surface()

    def update(self):
        if not self.active:
            return

        if self.fade_in and self.alpha < 255 and not self.start_fade:
            self.alpha = min(255, self.alpha + self.fade_speed)
        
        if not self.done_typing:
            self.typing_timer += 1
            if self.typing_timer >= self.typing_delay:
                self.typing_timer = 0
                self.text_index = min(self.text_index + self.typing_speed, 
                                    sum(len(line) for line in self.wrapped_text))
                if self.text_index >= sum(len(line) for line in self.wrapped_text):
                    self.done_typing = True
                self.create_surface()
        else:
            if not self.parent_button.player_on_button:
                self.start_fade = True
                
            if self.start_fade:
                self.display_timer += 1
                if self.display_timer >= self.display_time:
                    self.fade_in = False
                    self.alpha = max(0, self.alpha - self.fade_speed)
                    if self.alpha <= 0:
                        self.active = False
        
        self.image.set_alpha(self.alpha)
        
        if self.show_result:
            self.result_timer -= 1
            if self.result_timer <= 0:
                self.show_result = False
                self.selected_option = None

    def toggle_quiz_mode(self):
        self.show_quiz = not self.show_quiz
        if self.show_quiz:
            if self.quiz_system and self.planet_name:
                self.current_question = self.quiz_system.get_random_question(self.planet_name)
                self.show_result = False
        else:
            self.full_text = self.fact_text
            
    def display_current_question(self):
        if self.current_question:
            question_text = self.current_question['question']
            options = self.current_question['options']
            self.full_text = f"{question_text}\n"
            for i, option in enumerate(options):
                self.full_text += f"{i+1}. {option}\n"
            self.full_text += self.exit_text  # Add exit text to quiz questions
                
    def display_result(self):
        self.full_text = self.result_text
        
    def handle_answer(self, answer_index):
        if self.current_question and not self.show_result:
            correct_index = self.current_question['correct_answer']
            self.show_result = True
            if answer_index == correct_index:
                self.result_text = "Correct! Press Q for next question"
            else:
                correct_answer = self.current_question['options'][correct_index]
                self.result_text = f"Incorrect. The correct answer was: {correct_answer}\nPress Q for next question"

    def draw(self, surface):
        # Draw the main text (fact or quiz)
        # ... existing text drawing code ...

        # Draw the exit text separately in bottom right
        surface.blit(self.exit_surface, self.exit_rect)

class Platform(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height, color, planet_name=""):
        super().__init__()
        self.image = pygame.Surface((width, height))
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.planet_name = planet_name
        
        # Create planet-specific ground textures
        if planet_name == "Mercury":
            self.create_mercury_texture()
        elif planet_name == "Venus":
            self.create_venus_texture()
        elif planet_name == "Mars":
            self.create_mars_texture()
        elif planet_name == "Jupiter":
            self.create_jupiter_texture()
        elif planet_name == "Saturn":
            self.create_saturn_texture()
        elif planet_name == "Uranus":
            self.create_uranus_texture()
        elif planet_name == "Neptune":
            self.create_neptune_texture()
        else:
            self.image.fill(color)

    def create_mercury_texture(self):
        base_color = (120, 110, 100)
        self.image.fill(base_color)
        for _ in range(15):
            x = random.randint(0, self.image.get_width()-4)
            y = random.randint(0, self.image.get_height()-4)
            size = random.randint(2, 6)
            color = (random.randint(140, 160), random.randint(130, 150), random.randint(120, 140))
            pygame.draw.circle(self.image, color, (x, y), size)

    def create_venus_texture(self):
        base_color = (170, 140, 90)
        self.image.fill(base_color)
        for _ in range(12):
            x = random.randint(0, self.image.get_width()-4)
            y = random.randint(0, self.image.get_height()-4)
            size = random.randint(2, 5)
            color = (random.randint(200, 255), random.randint(150, 200), random.randint(50, 100))
            pygame.draw.circle(self.image, color, (x, y), size)

    def create_mars_texture(self):
        base_color = (180, 90, 70)
        self.image.fill(base_color)
        for _ in range(14):
            x = random.randint(0, self.image.get_width()-4)
            y = random.randint(0, self.image.get_height()-4)
            size = random.randint(2, 5)
            color = (random.randint(200, 220), random.randint(80, 100), random.randint(60, 80))
            pygame.draw.circle(self.image, color, (x, y), size)

    def create_jupiter_texture(self):
        base_color = (160, 140, 110)
        self.image.fill(base_color)
        for _ in range(16):
            x = random.randint(0, self.image.get_width()-4)
            y = random.randint(0, self.image.get_height()-4)
            size = random.randint(3, 7)
            color = (random.randint(180, 200), random.randint(150, 170), random.randint(120, 140))
            pygame.draw.circle(self.image, color, (x, y), size)

    def create_saturn_texture(self):
        base_color = (180, 160, 120)
        self.image.fill(base_color)
        for _ in range(13):
            x = random.randint(0, self.image.get_width()-4)
            y = random.randint(0, self.image.get_height()-4)
            size = random.randint(2, 6)
            color = (random.randint(200, 220), random.randint(180, 200), random.randint(140, 160))
            pygame.draw.circle(self.image, color, (x, y), size)

    def create_uranus_texture(self):
        base_color = (130, 160, 180)
        self.image.fill(base_color)
        for _ in range(15):
            x = random.randint(0, self.image.get_width()-4)
            y = random.randint(0, self.image.get_height()-4)
            size = random.randint(2, 5)
            color = (random.randint(140, 160), random.randint(170, 190), random.randint(200, 220))
            pygame.draw.circle(self.image, color, (x, y), size)

    def create_neptune_texture(self):
        base_color = (100, 130, 190)
        self.image.fill(base_color)
        for _ in range(14):
            x = random.randint(0, self.image.get_width()-4)
            y = random.randint(0, self.image.get_height()-4)
            size = random.randint(2, 6)
            color = (random.randint(110, 130), random.randint(140, 160), random.randint(200, 220))
            pygame.draw.circle(self.image, color, (x, y), size)

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.width = PLAYER_WIDTH
        self.height = PLAYER_HEIGHT
        self.image = pygame.Surface((self.width, self.height), pygame.SRCALPHA)
        
        # Create a fallback frame
        self.fallback_frame = pygame.Surface((self.width, self.height), pygame.SRCALPHA)
        pygame.draw.rect(self.fallback_frame, (255, 0, 0), self.fallback_frame.get_rect())
        
        # Initialize animations with fallback frame
        self.animations = {
            'idle': [self.fallback_frame],
            'running': [self.fallback_frame],
            'jumping': [self.fallback_frame]
        }
        
        # Try to load animations
        self.load_all_animations()
        
        # Set initial animation
        self.current_animation = 'idle'
        self.animation_frame = 0
        self.animation_timer = 0
        self.animation_speed = 0.15
        
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        
        # Movement variables
        self.change_x = 0
        self.change_y = 0
        self.platforms = None
        self.facing_right = True
        self.is_jumping = False
        self.speed = 5
        self.jump_speed = -15
        self.gravity = 0.8
        self.velocity_y = 0
        self.on_ground = False
    
    def load_all_animations(self):
        # Try to load each animation
        if self.load_animation('idle', 1):
            self.animations['idle'] = self.load_animation('idle', 1)
        if self.load_animation('running', 8):
            self.animations['running'] = self.load_animation('running', 8)
        if self.load_animation('jumping', 1):
            self.animations['jumping'] = self.load_animation('jumping', 1)

    def load_animation(self, animation_name, frame_count):
        frames = []
        animation_path = os.path.join('assets', 'animations', animation_name)
        
        try:
            # First check if the directory exists
            if not os.path.exists(animation_path):
                print(f"Warning: Animation directory not found: {animation_path}")
                return [self.fallback_frame]
            
            # Load frames using the specific naming convention
            for i in range(1, frame_count + 1):
                frame_name = f"{animation_name}Frame{i}.png"
                frame_path = os.path.join(animation_path, frame_name)
                
                if os.path.exists(frame_path):
                    try:
                        frame = pygame.image.load(frame_path).convert_alpha()
                        frame = pygame.transform.scale(frame, (self.width, self.height))
                        frames.append(frame)
                    except pygame.error as e:
                        print(f"Error loading frame {frame_name}: {e}")
                        return [self.fallback_frame]
                else:
                    print(f"Frame not found: {frame_path}")
                    return [self.fallback_frame]
            
            return frames if frames else [self.fallback_frame]
            
        except Exception as e:
            print(f"Error in load_animation: {e}")
            return [self.fallback_frame]

    def update(self):
        # Get keyboard state
        keys = pygame.key.get_pressed()
        
        # Horizontal movement
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.rect.x -= self.speed
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.rect.x += self.speed
            
        # Jumping
        if (keys[pygame.K_SPACE] or keys[pygame.K_UP] or keys[pygame.K_w]) and self.on_ground:
            self.velocity_y = self.jump_speed
            self.on_ground = False
            
        # Apply gravity
        self.velocity_y += self.gravity
        self.rect.y += self.velocity_y
        
        # Keep player in bounds
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
        
        # Update animation state with safety checks
        try:
            if self.is_jumping:
                self.current_animation = 'jumping'
            elif self.change_x != 0:
                self.current_animation = 'running'
            else:
                self.current_animation = 'idle'
            
            # Safely get the current animation frames
            current_frames = self.animations.get(self.current_animation, [self.fallback_frame])
            if not current_frames:
                current_frames = [self.fallback_frame]
            
            # Update animation frame
            self.animation_timer += self.animation_speed
            if self.animation_timer >= 1:
                self.animation_timer = 0
                self.animation_frame = (self.animation_frame + 1) % len(current_frames)
            
            # Safely get current frame
            current_frame = current_frames[min(self.animation_frame, len(current_frames) - 1)]
            
            # Update image
            if not self.facing_right:
                self.image = pygame.transform.flip(current_frame, True, False)
            else:
                self.image = current_frame
                
        except Exception as e:
            print(f"Animation error: {e}")
            self.image = self.fallback_frame
    
    def jump(self):
        # Check if we're standing on a platform
        self.rect.y += 2
        platform_hit_list = pygame.sprite.spritecollide(self, self.platforms, False)
        self.rect.y -= 2
        
        if len(platform_hit_list) > 0:
            self.change_y = JUMP_SPEED
            self.is_jumping = True
    
    def go_left(self):
        self.change_x = -MOVE_SPEED
        self.facing_right = False
    
    def go_right(self):
        self.change_x = MOVE_SPEED
        self.facing_right = True
    
    def stop(self):
        self.change_x = 0

class PlanetPlatformer:
    def __init__(self, planet_name, planet_color, planet_facts, background_color=(0, 0, 0)):
        self.screen = pygame.display.get_surface()
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 36)
        
        self.planet_name = planet_name
        self.planet_color = planet_color
        self.planet_facts = planet_facts  # Store as list of facts
        self.background_color = background_color
        
        # Load the background with planet name
        self.background = Background(
            os.path.join("assets", "mountainsfardetail.png"),
            is_earth=(planet_name == "Earth"),
            planet_name=planet_name
        )
        
        # Create sprite groups
        self.all_sprites = pygame.sprite.Group()
        self.platforms = pygame.sprite.Group()
        self.info_buttons = pygame.sprite.Group()
        self.info_bubbles = pygame.sprite.Group()

        # Create the player the same way for all planets
        self.player = Player(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 100)
        self.player.platforms = self.platforms
        self.all_sprites.add(self.player)

        # Create camera
        self.camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)

        # Create the level
        self.create_level()

        self.quiz_system = QuizSystem()

        # Add menu text
        self.menu_font = pygame.font.Font(None, 32)
        self.menu_text = "Press Escape to go back to menu"
        self.menu_surface = self.menu_font.render(self.menu_text, True, (255, 255, 255))
        self.menu_rect = self.menu_surface.get_rect()
        
        # Position at bottom right of the screen
        self.menu_rect.bottomright = (SCREEN_WIDTH - 20, SCREEN_HEIGHT - 20)

        self.game_state = "main"  # Can be "main", "facts", "quiz"
        self.previous_state = None

    def create_level(self):
        # Create ground
        ground_y = SCREEN_HEIGHT - TILE_SIZE
        for x in range(0, WORLD_WIDTH + TILE_SIZE, TILE_SIZE):
            platform = Platform(x, ground_y, TILE_SIZE, TILE_SIZE, 
                             self.planet_color, self.planet_name)
            self.platforms.add(platform)
            self.all_sprites.add(platform)
        
        # Add info buttons along the ground
        button_spacing = WORLD_WIDTH // (len(self.planet_facts) + 1)
        for i in range(len(self.planet_facts)):
            x = (i + 1) * button_spacing
            button = InfoButton(x, SCREEN_HEIGHT - TILE_SIZE)
            self.info_buttons.add(button)
            self.all_sprites.add(button)

    def check_button_collisions(self):
        for button in self.info_buttons:
            if pygame.sprite.collide_rect(self.player, button):
                if not button.button_pressed and button.cooldown == 0:
                    button.button_pressed = True  # Mark button as pressed
                    button.cooldown = 30
                    
                    # Remove existing info bubbles
                    for bubble in self.info_bubbles:
                        bubble.kill()
                    self.info_bubbles.empty()
                    
                    # Create new info bubble
                    index = list(self.info_buttons).index(button)
                    bubble = InfoBubble(
                        self.player.rect.centerx,
                        200,
                        index,
                        button,
                        self.planet_facts,
                        self.quiz_system,
                        self.planet_name
                    )
                    bubble.parent_game = self  # Set the reference to the game
                    self.info_bubbles.add(bubble)
                    self.all_sprites.add(bubble)

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
                
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.handle_escape()
                # ... handle other key events ...

    def handle_escape(self):
        # Remove any active info bubbles
        for bubble in self.info_bubbles:
            bubble.kill()
        self.info_bubbles.empty()
        
        if self.game_state == "facts":
            self.game_state = "main"
        elif self.game_state == "quiz":
            self.game_state = "main"
        elif self.game_state == "question":
            self.game_state = "quiz"

    def check_collisions(self):
        # Check platform collisions
        for platform in self.platforms:
            if pygame.sprite.collide_rect(self.player, platform):
                # If falling
                if self.player.velocity_y > 0:
                    self.player.rect.bottom = platform.rect.top
                    self.player.velocity_y = 0
                    self.player.on_ground = True
                # If jumping
                elif self.player.velocity_y < 0:
                    self.player.rect.top = platform.rect.bottom
                    self.player.velocity_y = 0

    def run(self):
        running = True
        while running:
            if self.game_state == "menu":
                # Menu state code
                running = self.run_menu()
            else:
                # Game state code
                self.screen.fill(BLACK)
                self.check_collisions()
                self.check_button_collisions()
                self.player.update()
                self.all_sprites.update()
                
                # Draw everything
                self.all_sprites.draw(self.screen)
                
                # Handle events
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        running = False
                    elif event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_ESCAPE:
                            self.game_state = "menu"
            
            pygame.display.flip()
            self.clock.tick(60)
            
        return True

    def draw_main_menu(self):
        self.screen.fill(self.background_color)
        # Draw buttons for Facts and Quiz options
        # ... drawing code for main menu ...

    def draw_facts_mode(self):
        # Draw the background
        self.screen.fill(self.background_color)
        self.background.draw(self.screen, 0)
        
        # Update and draw player animations in facts mode
        self.player.current_animation = 'idle'  # Use idle animation in facts mode
        self.player.animation_timer += 1
        if self.player.animation_timer >= 10:  # Adjust animation speed
            self.player.animation_timer = 0
            self.player.animation_frame = (self.player.animation_frame + 1) % len(self.player.animations[self.player.current_animation])
        
        # Update player image with current animation frame
        current_frame = self.player.animations[self.player.current_animation][self.player.animation_frame]
        if not self.player.facing_right:
            current_frame = pygame.transform.flip(current_frame, True, False)
        self.player.image = current_frame
        
        # Draw the player
        self.screen.blit(self.player.image, self.player.rect)
        
        # Draw info bubbles
        self.info_bubbles.draw(self.screen)
        self.info_bubbles.update()
        
        # Draw "Press Escape to go back to menu"
        self.screen.blit(self.menu_surface, self.menu_rect)

    def draw_quiz_mode(self):
        self.screen.fill(self.background_color)
        # Draw quiz selection interface
        # ... drawing code for quiz mode ...
        self.screen.blit(self.menu_surface, self.menu_rect)

    def draw_quiz_question(self):
        self.screen.fill(self.background_color)
        # Draw current quiz question
        # ... drawing code for quiz question ...
        self.screen.blit(self.menu_surface, self.menu_rect)

if __name__ == "__main__":
    # Set up the display
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("Planet Platformer")
    
    # Example planet facts (as a list)
    mercury_facts = [
        "Mercury is the smallest planet in our solar system.",
        "Mercury's surface temperature varies the most, from -280°F to 800°F.",
        "Mercury completes one orbit around the Sun in just 88 Earth days.",
        "Mercury's surface is heavily cratered, similar to Earth's Moon.",
        "Mercury has no atmosphere but has a thin exosphere.",
        "Mercury's core makes up about 55% of its volume.",
        "Mercury is named after the Roman messenger god.",
        "Mercury has the most eccentric orbit of all planets.",
        "Mercury's surface gravity is about 38% of Earth's.",
        "Mercury has ice in its permanently shadowed craters."
    ]
    
    venus_facts = [
        "Venus is the hottest planet with surface temperatures of 880°F.",
        "Venus rotates backwards compared to most planets.",
        "Venus has the longest rotation period of any planet.",
        "Venus's atmosphere is 96% carbon dioxide.",
        "Venus has more volcanoes than any other planet.",
        "Venus is the brightest natural object in Earth's night sky.",
        "A day on Venus is longer than its year.",
        "Venus has no moons or rings.",
        "Venus's surface pressure is 90 times that of Earth.",
        "Venus is sometimes called Earth's twin due to similar size."
    ]
    
    mars_facts = [
        "Mars has the largest volcano in the solar system: Olympus Mons.",
        "Mars has two small moons: Phobos and Deimos.",
        "The red color comes from iron oxide (rust) on its surface.",
        "Mars has the largest canyon in the solar system: Valles Marineris.",
        "Scientists have found evidence of ancient water flows on Mars.",
        "The planet experiences frequent dust storms.",
        "Mars' atmosphere is primarily carbon dioxide.",
        "The planet has polar ice caps made of water and CO2 ice.",
        "A year on Mars is about 687 Earth days.",
        "Mars has about 38% of Earth's gravity."
    ]
    
    jupiter_facts = [
        "Jupiter is the largest planet in our solar system.\n\n                                Press Escape to exit",
        "Jupiter's Great Red Spot is a giant storm lasting over 400 years.\n\n                                Press Escape to exit",
        "Jupiter has at least 79 moons.\n\n                                Press Escape to exit",
        "Jupiter's magnetic field is the strongest of all planets.\n\n                                Press Escape to exit",
        "Jupiter rotates faster than any other planet.\n\n                                Press Escape to exit",
        "Jupiter's atmosphere is mostly hydrogen and helium.\n\n                                Press Escape to exit",
        "Jupiter's mass is more than twice that of all other planets combined.\n\n                                Press Escape to exit",
        "Jupiter's day is only about 10 Earth hours long.\n\n                                Press Escape to exit",
        "Jupiter has a faint ring system.\n\n                                Press Escape to exit",
        "Jupiter's moon Ganymede is larger than Mercury.\n\n                                Press Escape to exit"
    ]
    
    saturn_facts = [
        "Saturn's rings are mostly made of ice and rock.\n\n                                Press Escape to exit",
        "Saturn could float in water due to its low density.\n\n                                Press Escape to exit",
        "Saturn has at least 82 moons.\n\n                                Press Escape to exit",
        "Saturn's largest moon Titan has a thick atmosphere.\n\n                                Press Escape to exit",
        "Saturn's rings span up to 175,000 miles wide.\n\n                                Press Escape to exit",
        "Saturn's average temperature is -178°C (-288°F).\n\n                                Press Escape to exit",
        "Saturn completes one orbit around the Sun in 29.5 Earth years.\n\n                                Press Escape to exit",
        "Saturn's wind speeds can reach 1,100 mph.\n\n                                Press Escape to exit",
        "Saturn's rings are only about 30 feet thick on average.\n\n                                Press Escape to exit",
        "Saturn has hexagonal-shaped storms at its poles.\n\n                                Press Escape to exit"
    ]
    
    uranus_facts = [
        "Uranus rotates on its side, unlike other planets.\n\n                                Press Escape to exit",
        "Uranus was the first planet discovered using a telescope.\n\n                                Press Escape to exit",
        "Uranus has 27 known moons.\n\n                                Press Escape to exit",
        "Uranus is an ice giant planet.\n\n                                Press Escape to exit",
        "Uranus has 13 known rings.\n\n                                Press Escape to exit",
        "Uranus takes 84 Earth years to orbit the Sun.\n\n                                Press Escape to exit",
        "Uranus is the coldest planet with temperatures of -224°C.\n\n                                Press Escape to exit",
        "Uranus's moons are named after literary characters.\n\n                                Press Escape to exit",
        "Uranus appears blue-green due to methane in its atmosphere.\n\n                                Press Escape to exit",
        "Uranus has extreme seasons lasting 20 Earth years.\n\n                                Press Escape to exit"
    ]
    
    neptune_facts = [
        "Neptune has the strongest winds in the solar system.\n\n                                Press Escape to exit",
        "Neptune was discovered through mathematical predictions.\n\n                                Press Escape to exit",
        "Neptune has 14 known moons.\n\n                                Press Escape to exit",
        "Neptune's largest moon Triton orbits backwards.\n\n                                Press Escape to exit",
        "Neptune has five main rings.\n\n                                Press Escape to exit",
        "Neptune takes 165 Earth years to orbit the Sun.\n\n                                Press Escape to exit",
        "Neptune's winds can reach speeds of 1,200 mph.\n\n                                Press Escape to exit",
        "Neptune has a Great Dark Spot similar to Jupiter's Great Red Spot.\n\n                                Press Escape to exit",
        "Neptune is the densest giant planet.\n\n                                Press Escape to exit",
        "Neptune's atmosphere contains methane, giving it its blue color.\n\n                                Press Escape to exit"
    ]
    
    # Create and run the game
    game = PlanetPlatformer(
        planet_name="Mars",
        planet_color=(200, 100, 100),
        planet_facts=mars_facts  # Pass the list of facts
    )
    
    if not game.run():
        pygame.quit()
        sys.exit()